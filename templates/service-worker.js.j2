
/* Javascript functions to handle offline mode.
 * When supported by a browser, this service worker provides the same
 * functionality as the applicationcache, but in a non-deprecated manner.
 * Francois Botman, 2017.
 */

var offline_handler = self;
var root = (function() {
  var tokens = (self.location + '').split('/');
  tokens[tokens.length - 1] = '';
  return tokens.join('/');
})();


// Version information (for updating this file):
{{ VERSION_DIFF }}

var version = 'v2';

offline_handler.addEventListener('install', function(event) {
    console.log('[ServiceWorker] Installed version', version);
    console.log('[ServiceWorker] Caching started for', version);
    event.waitUntil(
        caches.open(version).then(cache => {
            return cache.addAll([
                {{ OFFLINE_FILE_LIST | safe }}
            ]);
        }).then(() => {
            console.log('[ServiceWorker] Caching complete for', version);
            console.log('[ServiceWorker] Skip waiting on install');
            self.skipWaiting();
        })
    );
});

self.addEventListener('activate', function(event) {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== version) {
            console.log('[ServiceWorker] Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    }).then(() => {
      console.log('[ServiceWorker] Claiming clients for version', version);
      return self.clients.claim();
    })
  );
});

const fetchAndCache = (request) => {
    return fetch(request, {mode: 'cors', redirect: 'manual', cache: "no-cache"}).then((response) => {
        // If the response code is not 200, then we need to simply return and
        // not add this to the cache.
        if (!response || response.status != 200) return response;

        // If the request has prohibited items in it, then avoid caching
        if(request.url.match("anticaching")) return response;
        if(request.url.match("^/admin")) return response;
        if(request.url.match("^/login")) return response;
        if(request.url.match("^/token")) return response;
        if(request.url.match("^/docs")) return response;
        if(!request.url.startsWith("http")) return response;

        return caches.open(version).then(function(cache) {
            cache.put(request, response.clone());
            return response;
        });
    }).catch(() => {
        return caches.match(request);
    });
}

offline_handler.addEventListener('fetch', function(event) {
    const url_path = new URL(event.request.url).pathname

    if(event.request.method == "GET") {
        // The following are network first requests, otherwise it is cache first
        if(url_path == "/" || url_path.match("^/review") || url_path.match("^/admin") ||
           url_path.match("^/docs") || url_path.match("^/rss") || url_path.match("^/openapi.json") ||
           url_path.match("^/index.cgi"))
            event.respondWith(fetchAndCache(event.request));
        else
            event.respondWith(caches.match(event.request).then((response) => response || fetchAndCache(event.request)));
    }

    // Otherwise fallback to the default action -- this can be done by simply not
    // calling respondWith.
});
